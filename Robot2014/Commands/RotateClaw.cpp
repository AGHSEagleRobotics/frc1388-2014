 // RobotBuilder Version: 0.0.2
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "RotateClaw.h"
#include "../Subsystems/Claw.h"
#include <math.h>
#define OPSTICK_CONVERSION_FACTOR 15
RotateClaw::RotateClaw() {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
	Requires(Robot::claw);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
}
// Called just before this Command runs the first time
void RotateClaw::Initialize() {
	Robot::claw->Enable();//enable PID Controller
	}
// Called repeatedly when this Command is scheduled to run
void RotateClaw::Execute() {
	//there is a negative in this line beacuse the joystick needed to be inverted 
	float opStickY = -(Robot::oi->getOpStick()->GetY());
	float currentPosition = Robot::claw->quadClawEncoder->GetDistance();
	bool backLimit = Robot::claw->backLimitSwitch->Get();
	float currentsetpoint = Robot::claw->GetSetpoint();
	
	if (Robot::claw->initializedPosition == false){	
		if(backLimit == true){
			//This code resets the pid controller and the claw encoder so they will function  
			Robot::claw->Disable();//Disable PID Controller
			Robot::claw->quadClawEncoder->Reset();
			Robot::claw->SetSetpoint(POSITION_UP);
			Robot::claw->Reset();
			Robot::claw->Enable();//enable PID Controller
			Robot::claw->SetInputRange(CLAW_RANGE_MIN,CLAW_RANGE_MAX);
			Robot::claw->initializedPosition = true;
		}	
		if (backLimit == false){
			//this code makes the arm go to the zero position if the backlimitswitch is false
			Robot::claw->SetSetpointRelative(-SMALL_MOVEMENT);
			
		}
	} else {
				//this command take the absolute value of the joystick value
		//and if that value is of substantial value then use direct drive
		if (fabs(opStickY) > 0.1)
		{
			float target = currentPosition + (opStickY * OPSTICK_CONVERSION_FACTOR);
			Robot::claw->SetSetpoint(target);
			
		//This code is here incase we want to reset the encoder whenever during the game	
//			if(Robot::claw->backLimitSwitch->Get() == true){
//						//This code resets the pid controller and the claw encoder so they will function  
//						Robot::claw->Disable();//Disable PID Controller
//						Robot::claw->quadClawEncoder->Reset();
//						Robot::claw->SetSetpoint(POSITION_UP);
//						Robot::claw->Reset();
//						Robot::claw->Enable();//enable PID Controller
//						Robot::claw->SetInputRange(CLAW_RANGE_MIN,CLAW_RANGE_MAX);
			}
		
		printf("Encoder Value: %f", Robot::claw->quadClawEncoder->GetDistance());
		
	}
}                                                             
// Make this return true when this Command no longer needs to run execute()
bool RotateClaw::IsFinished() {                                 
	return false;                                                
}                                                                 
// Called once after isFinished returns true                       
void RotateClaw::End() {                                                                                                       
                                                                    	
}                                                                     
// Called when another command which requires one or more of the same   
// subsystems is scheduled to run
void RotateClaw::Interrupted() {
}
